require 'rails_helper'

RSpec.describe 'Api::V1::PrayerIntentions', type: :request do
  let(:user) { create(:user) }
  let(:other_user) { create(:user, firebase_uid: 'other-uid', email: 'other@example.com') }
  let(:headers) { { 'Authorization' => \"Bearer #{generate_jwt_token(user)}\" } }
  let(:other_headers) { { 'Authorization' => \"Bearer #{generate_jwt_token(other_user)}\" } }
  \n  describe 'GET /api/v1/prayer_intentions' do\n    let!(:user_intentions) { create_list(:prayer_intention, 3, user: user) }\n    let!(:other_user_intentions) { create_list(:prayer_intention, 2, user: other_user) }\n    \n    it 'returns only user\\'s prayer intentions' do\n      get '/api/v1/prayer_intentions', headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].length).to eq(3)\n      expect(json['meta']).to include('current_page', 'total_pages', 'total_count')\n    end\n    \n    it 'does not return other users\\' intentions' do\n      get '/api/v1/prayer_intentions', headers: headers\n      \n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].length).to eq(3)\n    end\n    \n    it 'filters by status' do\n      create(:prayer_intention, user: user, status: :answered)\n      create(:prayer_intention, user: user, status: :pending)\n      \n      get '/api/v1/prayer_intentions', params: { status: 'answered' }, headers: headers\n      \n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].all? { |i| i['status'] == 'answered' }).to be true\n    end\n    \n    it 'filters by category' do\n      create(:prayer_intention, user: user, category: 'personal')\n      create(:prayer_intention, user: user, category: 'family')\n      \n      get '/api/v1/prayer_intentions', params: { category: 'personal' }, headers: headers\n      \n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].all? { |i| i['category'] == 'personal' }).to be true\n    end\n    \n    it 'filters by prayer generation status' do\n      create(:prayer_intention, user: user, :with_prayer)\n      create(:prayer_intention, user: user)\n      \n      get '/api/v1/prayer_intentions', params: { has_prayer: true }, headers: headers\n      \n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].all? { |i| i['ai_enriched_at'].present? }).to be true\n    end\n    \n    it 'searches by title and description' do\n      create(:prayer_intention, user: user, title: 'Healing prayer')\n      create(:prayer_intention, user: user, title: 'Guidance needed')\n      \n      get '/api/v1/prayer_intentions', params: { search: 'healing' }, headers: headers\n      \n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].length).to eq(1)\n      expect(json['prayer_intentions'].first['title']).to include('Healing')\n    end\n    \n    it 'paginates results' do\n      create_list(:prayer_intention, 25, user: user)\n      \n      get '/api/v1/prayer_intentions', params: { per_page: 10, page: 1 }, headers: headers\n      \n      json = JSON.parse(response.body)\n      expect(json['prayer_intentions'].length).to eq(10)\n      expect(json['meta']['current_page']).to eq(1)\n      expect(json['meta']['total_pages']).to eq(3)\n    end\n    \n    it 'requires authentication' do\n      get '/api/v1/prayer_intentions'\n      \n      expect(response).to have_http_status(:unauthorized)\n    end\n  end\n  \n  describe 'GET /api/v1/prayer_intentions/:id' do\n    let(:intention) { create(:prayer_intention, user: user) }\n    \n    it 'returns the prayer intention' do\n      get \"/api/v1/prayer_intentions/#{intention.id}\", headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['prayer_intention']['id']).to eq(intention.id)\n      expect(json['prayer_intention']['title']).to eq(intention.title)\n    end\n    \n    it 'returns 404 for non-existent intention' do\n      get '/api/v1/prayer_intentions/99999', headers: headers\n      \n      expect(response).to have_http_status(:not_found)\n      json = JSON.parse(response.body)\n      expect(json['error']).to eq('Prayer intention not found')\n    end\n    \n    it 'does not allow viewing other users\\' intentions' do\n      other_intention = create(:prayer_intention, user: other_user)\n      \n      get \"/api/v1/prayer_intentions/#{other_intention.id}\", headers: headers\n      \n      expect(response).to have_http_status(:forbidden)\n    end\n  end\n  \n  describe 'POST /api/v1/prayer_intentions' do\n    let(:valid_params) do\n      {\n        prayer_intention: {\n          title: 'Healing for my mother',\n          description: 'Praying for complete healing',\n          category: 'intercession'\n        }\n      }\n    end\n    \n    it 'creates a prayer intention' do\n      expect {\n        post '/api/v1/prayer_intentions', params: valid_params, headers: headers\n      }.to change(PrayerIntention, :count).by(1)\n      \n      expect(response).to have_http_status(:created)\n      json = JSON.parse(response.body)\n      expect(json['prayer_intention']['title']).to eq('Healing for my mother')\n      expect(json['message']).to eq('Prayer intention created successfully')\n    end\n    \n    it 'associates intention with current user' do\n      post '/api/v1/prayer_intentions', params: valid_params, headers: headers\n      \n      intention = PrayerIntention.last\n      expect(intention.user_id).to eq(user.id)\n    end\n    \n    it 'triggers async prayer generation when auto_generate is true' do\n      params = valid_params.merge(auto_generate: true)\n      \n      expect(EnrichPrayerIntentionJob).to receive(:perform_later)\n      \n      post '/api/v1/prayer_intentions', params: params, headers: headers\n    end\n    \n    it 'returns errors for invalid data' do\n      invalid_params = { prayer_intention: { title: 'ab' } } # Too short\n      \n      post '/api/v1/prayer_intentions', params: invalid_params, headers: headers\n      \n      expect(response).to have_http_status(:unprocessable_entity)\n      json = JSON.parse(response.body)\n      expect(json['errors']).to be_present\n    end\n  end\n  \n  describe 'PATCH /api/v1/prayer_intentions/:id' do\n    let(:intention) { create(:prayer_intention, user: user, title: 'Original title') }\n    \n    it 'updates the prayer intention' do\n      patch \"/api/v1/prayer_intentions/#{intention.id}\",\n            params: { prayer_intention: { title: 'Updated title' } },\n            headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['prayer_intention']['title']).to eq('Updated title')\n      expect(intention.reload.title).to eq('Updated title')\n    end\n    \n    it 'does not allow updating other users\\' intentions' do\n      other_intention = create(:prayer_intention, user: other_user)\n      \n      patch \"/api/v1/prayer_intentions/#{other_intention.id}\",\n            params: { prayer_intention: { title: 'Hacked' } },\n            headers: headers\n      \n      expect(response).to have_http_status(:forbidden)\n    end\n  end\n  \n  describe 'DELETE /api/v1/prayer_intentions/:id' do\n    let(:intention) { create(:prayer_intention, user: user) }\n    \n    it 'deletes the prayer intention' do\n      intention # Create it first\n      \n      expect {\n        delete \"/api/v1/prayer_intentions/#{intention.id}\", headers: headers\n      }.to change(PrayerIntention, :count).by(-1)\n      \n      expect(response).to have_http_status(:ok)\n    end\n    \n    it 'does not allow deleting other users\\' intentions' do\n      other_intention = create(:prayer_intention, user: other_user)\n      \n      expect {\n        delete \"/api/v1/prayer_intentions/#{other_intention.id}\", headers: headers\n      }.not_to change(PrayerIntention, :count)\n      \n      expect(response).to have_http_status(:forbidden)\n    end\n  end\n  \n  describe 'POST /api/v1/prayer_intentions/:id/generate_prayer' do\n    let(:intention) { create(:prayer_intention, user: user) }\n    \n    it 'triggers prayer generation' do\n      expect(EnrichPrayerIntentionJob).to receive(:perform_later).with(intention.id)\n      \n      post \"/api/v1/prayer_intentions/#{intention.id}/generate_prayer\", headers: headers\n      \n      expect(response).to have_http_status(:accepted)\n      json = JSON.parse(response.body)\n      expect(json['message']).to include('Prayer generation started')\n    end\n    \n    it 'does not regenerate without force flag' do\n      intention.mark_as_ai_enriched!\n      \n      expect(EnrichPrayerIntentionJob).not_to receive(:perform_later)\n      \n      post \"/api/v1/prayer_intentions/#{intention.id}/generate_prayer\", headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['message']).to include('already generated')\n    end\n    \n    it 'regenerates with force=true' do\n      intention.mark_as_ai_enriched!\n      \n      expect(EnrichPrayerIntentionJob).to receive(:perform_later).with(intention.id)\n      \n      post \"/api/v1/prayer_intentions/#{intention.id}/generate_prayer\",\n           params: { force: true },\n           headers: headers\n      \n      expect(response).to have_http_status(:accepted)\n    end\n  end\n  \n  describe 'POST /api/v1/prayer_intentions/:id/mark_answered' do\n    let(:intention) { create(:prayer_intention, user: user, status: :praying) }\n    \n    it 'marks the prayer as answered' do\n      post \"/api/v1/prayer_intentions/#{intention.id}/mark_answered\",\n           params: { answer_notes: 'God provided healing' },\n           headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['prayer_intention']['status']).to eq('answered')\n      expect(json['prayer_intention']['answer_notes']).to eq('God provided healing')\n      \n      intention.reload\n      expect(intention.answered_at).to be_present\n    end\n  end\n  \n  describe 'POST /api/v1/prayer_intentions/:id/record_prayer' do\n    let(:intention) { create(:prayer_intention, user: user, prayer_count: 5) }\n    \n    it 'records the prayer' do\n      post \"/api/v1/prayer_intentions/#{intention.id}/record_prayer\", headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['message']).to eq('Prayer recorded')\n      \n      intention.reload\n      expect(intention.prayer_count).to eq(6)\n      expect(intention.last_prayed_at).to be_present\n    end\n    \n    it 'does not allow recording prayer for other users\\' intentions' do\n      other_intention = create(:prayer_intention, user: other_user)\n      \n      post \"/api/v1/prayer_intentions/#{other_intention.id}/record_prayer\", headers: headers\n      \n      expect(response).to have_http_status(:forbidden)\n    end\n  end\n  \n  describe 'POST /api/v1/prayer_intentions/:id/archive' do\n    let(:intention) { create(:prayer_intention, user: user, status: :answered) }\n    \n    it 'archives the prayer intention' do\n      post \"/api/v1/prayer_intentions/#{intention.id}/archive\", headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['prayer_intention']['status']).to eq('archived')\n      expect(intention.reload.status).to eq('archived')\n    end\n  end\n  \n  describe 'GET /api/v1/prayer_intentions/categories' do\n    it 'returns available categories' do\n      get '/api/v1/prayer_intentions/categories', headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      expect(json['categories']).to be_an(Array)\n      expect(json['categories'].first).to have_key('value')\n      expect(json['categories'].first).to have_key('label')\n    end\n  end\n  \n  describe 'GET /api/v1/prayer_intentions/stats' do\n    before do\n      create_list(:prayer_intention, 3, user: user, status: :pending)\n      create_list(:prayer_intention, 2, user: user, status: :answered)\n      create(:prayer_intention, user: user, status: :archived)\n      create(:prayer_intention, user: user, :with_prayer)\n      create(:prayer_intention, user: user, category: 'personal', prayer_count: 10)\n      create(:prayer_intention, user: user, category: 'family', prayer_count: 5)\n    end\n    \n    it 'returns user statistics' do\n      get '/api/v1/prayer_intentions/stats', headers: headers\n      \n      expect(response).to have_http_status(:ok)\n      json = JSON.parse(response.body)\n      stats = json['stats']\n      \n      expect(stats['total']).to eq(8)\n      expect(stats['active']).to eq(3)\n      expect(stats['answered']).to eq(2)\n      expect(stats['archived']).to eq(1)\n      expect(stats['with_prayer']).to eq(1)\n      expect(stats['total_prayers_prayed']).to eq(15)\n      expect(stats['by_category']).to be_a(Hash)\n    end\n  end\n  \n  # Helper method to generate JWT token for testing\n  def generate_jwt_token(user)\n    # This should match your actual JWT generation logic\n    payload = {\n      user_id: user.id,\n      firebase_uid: user.firebase_uid,\n      exp: 24.hours.from_now.to_i\n    }\n    JWT.encode(payload, Rails.application.credentials.secret_key_base, 'HS256')\n  end\nend\n