require 'rails_helper'

RSpec.describe PerplexityApiService do
  let(:api_key) { 'test_api_key' }
  let(:service) { described_class.new(api_key: api_key) }
  let(:user) { create(:user) }
  let(:prayer_intention) do\n    create(:prayer_intention,\n           user: user,\n           title: 'Healing',\n           description: 'For my mother',\n           category: 'intercession')\n  end\n  \n  before do\n    allow(ENV).to receive(:[]).with('PERPLEXITY_API_KEY').and_return(api_key)\n    allow(ENV).to receive(:[]).with('PERPLEXITY_API_URL').and_return('https://api.perplexity.ai')\n    allow(ENV).to receive(:fetch).with('PERPLEXITY_API_URL', 'https://api.perplexity.ai').and_return('https://api.perplexity.ai')\n  end\n  \n  describe '#initialize' do\n    it 'initializes with API key' do\n      expect(service.instance_variable_get(:@api_key)).to eq(api_key)\n    end\n    \n    it 'raises error when API key is missing' do\n      allow(ENV).to receive(:[]).with('PERPLEXITY_API_KEY').and_return(nil)\n      expect { described_class.new }.to raise_error(PerplexityApiService::PerplexityError, 'Perplexity API key not configured')\n    end\n    \n    it 'sets up rate limiting' do\n      expect(service.instance_variable_get(:@request_count)).to eq(0)\n      expect(service.instance_variable_get(:@rate_limit_reset_at)).to be_present\n    end\n  end\n  \n  describe '#generate_prayer' do\n    let(:mock_prayer) do\n      <<~PRAYER\n        Almighty God, the giver of life and health,\n        in whom is the source of all healing power:\n        Look with mercy upon your servant who is afflicted with illness,\n        grant them patience in their suffering,\n        and restore them to health of body and spirit;\n        through Jesus Christ our Lord. Amen.\n      PRAYER\n    end\n    \n    let(:mock_response) do\n      {\n        'choices' => [\n          {\n            'message' => {\n              'content' => mock_prayer\n            }\n          }\n        ]\n      }\n    end\n    \n    before do\n      allow(service).to receive(:make_api_request).and_return(mock_response)\n    end\n    \n    it 'generates an Anglican-style prayer' do\n      result = service.generate_prayer(prayer_intention)\n      \n      expect(result).to include('Almighty God')\n      expect(result).to include('through Jesus Christ our Lord')\n      expect(result).to include('Amen')\n    end\n    \n    it 'logs the generation process' do\n      expect(Rails.logger).to receive(:info).with(/Generating Anglican prayer for intention/)\n      expect(Rails.logger).to receive(:info).with(/Successfully generated prayer/)\n      \n      service.generate_prayer(prayer_intention)\n    end\n    \n    it 'calls API with appropriate prompt' do\n      expect(service).to receive(:make_api_request).with(\n        include('Anglican-style prayer'),\n        max_tokens: 1000\n      ).and_return(mock_response)\n      \n      service.generate_prayer(prayer_intention)\n    end\n    \n    it 'handles errors gracefully' do\n      allow(service).to receive(:make_api_request).and_raise(StandardError, 'API Error')\n      \n      expect(Rails.logger).to receive(:error).with(/Failed to generate prayer/)\n      expect { service.generate_prayer(prayer_intention) }\n        .to raise_error(PerplexityApiService::PerplexityError, /Prayer generation failed/)\n    end\n  end\n  \n  describe 'API request handling' do\n    let(:valid_response) do\n      instance_double(HTTParty::Response, code: 200, parsed_response: {\n        'choices' => [{ 'message' => { 'content' => 'Prayer text' } }]\n      })\n    end\n    \n    before do\n      allow(described_class).to receive(:post).and_return(valid_response)\n    end\n    \n    it 'makes successful API request' do\n      result = service.send(:make_api_request, 'Test prompt')\n      expect(result['choices']).to be_present\n    end\n    \n    it 'includes authorization header' do\n      expect(described_class).to receive(:post).with(\n        anything,\n        hash_including(headers: hash_including('Authorization' => \"Bearer #{api_key}\")),\n        anything\n      ).and_return(valid_response)\n      \n      service.send(:make_api_request, 'Test prompt')\n    end\n    \n    it 'uses correct model and parameters' do\n      expect(described_class).to receive(:post).with(\n        anything,\n        hash_including(body: include('llama-3.1-sonar-large-128k-online')),\n        anything\n      ).and_return(valid_response)\n      \n      service.send(:make_api_request, 'Test prompt')\n    end\n  end\n  \n  describe 'error handling' do\n    it 'handles authentication errors' do\n      error_response = instance_double(HTTParty::Response, code: 401, parsed_response: {})\n      allow(described_class).to receive(:post).and_return(error_response)\n      \n      expect { service.send(:make_api_request, 'Test') }\n        .to raise_error(PerplexityApiService::AuthenticationError, 'Invalid API key')\n    end\n    \n    it 'handles rate limit errors' do\n      error_response = instance_double(HTTParty::Response, code: 429, parsed_response: {})\n      allow(described_class).to receive(:post).and_return(error_response)\n      \n      expect { service.send(:make_api_request, 'Test') }\n        .to raise_error(PerplexityApiService::RateLimitError, 'Rate limit exceeded')\n    end\n    \n    it 'handles server errors' do\n      error_response = instance_double(HTTParty::Response, code: 500, parsed_response: {})\n      allow(described_class).to receive(:post).and_return(error_response)\n      \n      expect { service.send(:make_api_request, 'Test') }\n        .to raise_error(PerplexityApiService::PerplexityError, 'Perplexity API server error')\n    end\n    \n    it 'handles invalid response format' do\n      invalid_response = { 'invalid' => 'structure' }\n      \n      expect { service.send(:extract_text_from_response, invalid_response) }\n        .to raise_error(PerplexityApiService::InvalidResponseError, 'Invalid response format')\n    end\n  end\n  \n  describe 'rate limiting' do\n    it 'tracks request count' do\n      allow(described_class).to receive(:post).and_return(\n        instance_double(HTTParty::Response, code: 200, parsed_response: {\n          'choices' => [{ 'message' => { 'content' => 'Text' } }]\n        })\n      )\n      \n      expect { service.send(:make_api_request, 'Test') }\n        .to change { service.instance_variable_get(:@request_count) }.by(1)\n    end\n    \n    it 'raises error when rate limit exceeded' do\n      service.instance_variable_set(:@request_count, 20)\n      service.instance_variable_set(:@rate_limit_reset_at, 1.minute.from_now)\n      \n      expect { service.send(:check_rate_limit!) }\n        .to raise_error(PerplexityApiService::RateLimitError, /Rate limit exceeded/)\n    end\n    \n    it 'resets rate limit after time window' do\n      service.instance_variable_set(:@request_count, 20)\n      service.instance_variable_set(:@rate_limit_reset_at, 1.second.ago)\n      \n      service.send(:reset_rate_limit_if_needed!)\n      expect(service.instance_variable_get(:@request_count)).to eq(0)\n    end\n  end\n  \n  describe 'system prompt' do\n    it 'includes Anglican prayer composition context' do\n      prompt = service.send(:system_prompt)\n      expect(prompt).to include('Anglican priest')\n      expect(prompt).to include('Book of Common Prayer')\n      expect(prompt).to include('collect format')\n    end\n  end\n  \n  describe 'prayer prompt builder' do\n    it 'builds Anglican prayer prompt' do\n      prompt = service.send(:build_prayer_prompt, 'Healing prayer', 'intercession')\n      expect(prompt).to include('Healing prayer')\n      expect(prompt).to include('intercession')\n      expect(prompt).to include('Anglican-style prayer')\n      expect(prompt).to include('Book of Common Prayer')\n      expect(prompt).to include('invocation')\n      expect(prompt).to include('doxology')\n    end\n  end\nend\n